/* START OF CODE - Emergent - 2025-10-21 [18:06:30-EST] File: js/settings-preview-download.js.txt */

 /**
 * Settings + Preview + Download Section - PRODUCTION VERSION
 * 
 * FIXES:
 * - Replaced applyPreviewDisplayConstraints to prevent canvas stretching
 * - REMOVED text rendering from Star Map and Street Map (bare images for design use)
 * - KEPT text rendering ONLY for Canvas Layout and Combined views
 * - Fixed text positioning to prevent overlapping and duplication
 * - IMPLEMENTED clean border masking from scratch (borders hidden in overlap area)
 * - ADDED view tracking to prevent mismatched downloads
 * - ADDED Google Maps proxy to avoid CORS/canvas tainting issues
 * - COMPREHENSIVE alert system for user guidance
 * - PNG/JPG downloads fully working
 */

// Helper function to get backend URL for production deployment
function getBackendUrl() {
    // For production deployment on anythingpod.com
    const currentHost = window.location.origin;
    
    // If we're on localhost, use the backend port
    if (currentHost.includes('localhost') || currentHost.includes('127.0.0.1')) {
        return 'http://localhost:8001';
    }
    
    // For production on anythingpod.com, backend is at same domain
    return currentHost;
}

// Track which view was last generated
let lastGeneratedView = null;

// Wait for DOM to be fully loaded
document.addEventListener('DOMContentLoaded', function() {
    initializeButtons();
});

// --- FIXED: Display sizing helper that maintains aspect ratio ---
function applyPreviewDisplayConstraints(zoomPercent) {
    const canvas = document.getElementById('star-map-canvas');
    if (!canvas) return;
    
    // Remove any explicit width/height styles to prevent stretching
    canvas.style.width = '';
    canvas.style.height = '';
    
    // Let CSS handle the sizing naturally
    canvas.style.maxWidth = '100%';
    canvas.style.maxHeight = '70vh';
    canvas.style.objectFit = 'contain';
    canvas.style.display = 'block';
    canvas.style.margin = '0 auto';
    
    console.log('ğŸ”µ FIXED: Canvas display constraints applied without stretching');
}

// --- NEW: Text rendering helper for all views ---
function renderTextLayers(ctx, centerX, centerY, radius, borderWidth) {
    console.log('ğŸ”µ Rendering text layers...');
    
    const getEl = id => document.getElementById(id);
    const getVal = (id, def) => getEl(id)?.value || def;
    const getInt = (id, def) => parseInt(getVal(id, String(def))) || def;
    const getChecked = id => getEl(id)?.checked || false;
    const getRadioVal = (name, def) => {
        const checkedRadio = document.querySelector(`input[name="${name}"]:checked`);
        return checkedRadio ? checkedRadio.value : def;
    };
    
    const dateValue = getVal("date", "");
    const latFullFormatted = getVal("latitude", "");
    const lonFullFormatted = getVal("longitude", "");
    
    // Collect all text data
    const allTextData = [
        { id: 'entry1', text: getVal('text-entry-1', ''), fontFamily: getVal('font-family-1', 'Montserrat'), fontSize: parseInt(getVal('font-size-1', '28')), fontColor: getVal('font-color-1', '#FFFFFF'), isBold: getChecked('text-bold-1'), isItalic: getChecked('text-italic-1'), order: parseInt(getVal('text-placement-order-1', '1')), position: getRadioVal('text-placement-pos-1', 'below') },
        { id: 'entry2', text: getVal('text-entry-2', ''), fontFamily: getVal('font-family-2', 'Montserrat'), fontSize: parseInt(getVal('font-size-2', '16')), fontColor: getVal('font-color-2', '#FFFFFF'), isBold: getChecked('text-bold-2'), isItalic: getChecked('text-italic-2'), order: parseInt(getVal('text-placement-order-2', '2')), position: getRadioVal('text-placement-pos-2', 'below') },
        { id: 'entry3', text: getVal('text-entry-3', ''), fontFamily: getVal('font-family-3', 'Montserrat'), fontSize: parseInt(getVal('font-size-3', '14')), fontColor: getVal('font-color-3', '#FFFFFF'), isBold: getChecked('text-bold-3'), isItalic: getChecked('text-italic-3'), order: parseInt(getVal('text-placement-order-3', '3')), position: getRadioVal('text-placement-pos-3', 'below') },
        { id: 'entry4', text: getVal('text-entry-4', ''), fontFamily: getVal('font-family-4', 'Montserrat'), fontSize: parseInt(getVal('font-size-4', '14')), fontColor: getVal('font-color-4', '#FFFFFF'), isBold: getChecked('text-bold-4'), isItalic: getChecked('text-italic-4'), order: parseInt(getVal('text-placement-order-4', '4')), position: getRadioVal('text-placement-pos-4', 'below') },
        { id: 'date', text: (typeof formatDate === 'function') ? formatDate(dateValue) : dateValue, fontFamily: getVal('fixed-font-family-date', 'Arial'), fontSize: parseInt(getVal('fixed-font-size-date', '14')), fontColor: getVal('fixed-font-color-date', '#FFFFFF'), isBold: getChecked('fixed-text-bold-date'), isItalic: getChecked('fixed-text-italic-date'), order: parseInt(getVal('text-placement-order-date', '5')), position: getRadioVal('text-placement-pos-date', 'below') },
        { id: 'coords', text: `${latFullFormatted || '?'} | ${lonFullFormatted || '?'}`, fontFamily: getVal('fixed-font-family-coords', 'Arial'), fontSize: parseInt(getVal('fixed-font-size-coords', '14')), fontColor: getVal('fixed-font-color-coords', '#FFFFFF'), isBold: getChecked('fixed-text-bold-coords'), isItalic: getChecked('fixed-text-italic-coords'), order: parseInt(getVal('text-placement-order-coords', '6')), position: getRadioVal('text-placement-pos-coords', 'below') }
    ];
    
    const dynamicTextMargin = radius * 0.10;
    
    ctx.textAlign = 'center';
    const itemsToDraw = allTextData.filter(item => item.text && item.text.trim() !== '').sort((a, b) => a.order - b.order);
    const aboveItems = itemsToDraw.filter(item => item.position === 'above');
    const belowItems = itemsToDraw.filter(item => item.position === 'below');
    
    const applyFontStyle = (style) => {
        const fontWeight = style.isBold ? 'bold' : 'normal';
        const fontStyle = style.isItalic ? 'italic' : 'normal';
        const sizeNum = parseInt(style.fontSize) || 14;
        const sizeWithUnit = `${sizeNum}px`;
        const safeFontFamily = style.fontFamily.includes(' ') ? `"${style.fontFamily}"` : style.fontFamily;
        ctx.font = `${fontStyle} ${fontWeight} ${sizeWithUnit} ${safeFontFamily}`;
        ctx.fillStyle = style.fontColor;
        return sizeNum;
    };
    
    const textSpacing = 1.2;
    
    // Draw items BELOW
    let currentYBelow = centerY + radius + (borderWidth / 2) + dynamicTextMargin;
    ctx.textBaseline = 'top';
    belowItems.forEach((item) => {
        const fontSize = applyFontStyle(item);
        ctx.fillText(item.text, centerX, currentYBelow);
        currentYBelow += fontSize * textSpacing;
    });
    
    // Draw items ABOVE
    let currentYAbove = centerY - radius - (borderWidth / 2) - dynamicTextMargin;
    ctx.textBaseline = 'bottom';
    [...aboveItems].reverse().forEach((item) => {
        const fontSize = applyFontStyle(item);
        ctx.fillText(item.text, centerX, currentYAbove);
        currentYAbove -= fontSize * textSpacing;
    });
    
    console.log(`ğŸ”µ Rendered ${itemsToDraw.length} text items (${aboveItems.length} above, ${belowItems.length} below)`);
}

// --- Helpers added by Codex ---
function validateCoordinates() {
    const latStr = (document.getElementById('latitude') || {}).value || '';
    const lngStr = (document.getElementById('longitude') || {}).value || '';
    let lat, lng;
    if (typeof parseFormattedCoordinate === 'function') {
        lat = parseFormattedCoordinate(latStr, 'latitude');
        lng = parseFormattedCoordinate(lngStr, 'longitude');
    } else {
        lat = parseFloat(latStr);
        lng = parseFloat(lngStr);
    }
    return !isNaN(lat) && !isNaN(lng);
}

function resetCanvasToUserDimensions() {
    const canvas = document.getElementById('star-map-canvas');
    const widthInput = document.getElementById('output-width');
    const heightInput = document.getElementById('output-height');
    const width = parseInt(widthInput && widthInput.value) || canvas.width || 800;
    const height = parseInt(heightInput && heightInput.value) || canvas.height || 800;
    canvas.width = width;
    canvas.height = height;
    
    // FIXED: Apply display constraints without stretching
    const zoomSlider = document.getElementById('zoom-slider');
    applyPreviewDisplayConstraints(zoomSlider ? zoomSlider.value : 100);
    
    return { width, height };
}

/**
 * Initialize all buttons in the Settings + Preview + Download section
 */
function initializeButtons() {
    console.log("Initializing Settings + Preview + Download buttons");
    
    // Settings buttons
    document.getElementById('loadSettingsBtn').addEventListener('click', function() {
        console.log("Load Settings button clicked");
        if (typeof loadSavedSettings === 'function') {
            loadSavedSettings();
        } else {
            console.error("loadSavedSettings function not found");
        }
    });
    
    document.getElementById('saveSettingsBtn').addEventListener('click', function() {
        console.log("Save Settings button clicked");
        if (typeof saveCurrentSettings === 'function') {
            saveCurrentSettings();
        } else {
            console.error("saveCurrentSettings function not found");
        }
    });
    
    // View buttons
    document.getElementById('view-star-map-btn').addEventListener('click', viewStarMap);
    document.getElementById('view-street-map-btn').addEventListener('click', viewStreetMap);
    document.getElementById('view-star-map-canvas-btn').addEventListener('click', viewStarMapOnCanvas);
    document.getElementById('view-star-street-landscape-btn').addEventListener('click', viewStarStreetLandscape);
    document.getElementById('view-star-street-portrait-btn').addEventListener('click', viewStarStreetPortrait);
    
    // Download buttons
    document.getElementById('download-star-map-btn').addEventListener('click', downloadStarMap);
    document.getElementById('download-street-map-btn').addEventListener('click', downloadStreetMap);
    document.getElementById('download-star-map-canvas-btn').addEventListener('click', downloadStarMapWithCanvas);
    document.getElementById('download-star-street-landscape-btn').addEventListener('click', downloadStarStreetLandscape);
    document.getElementById('download-star-street-portrait-btn').addEventListener('click', downloadStarStreetPortrait);
}

/**
 * View the star map (just the star map itself, not on canvas)
 * FIXED VERSION - Uses arc() for perfect circles
 */
function viewStarMap() {
    console.log("ğŸ”µ View Star Map button clicked - FIXED VERSION");
    
    if (!validateCoordinates()) {
        alert("Please enter valid coordinates or a location first.");
        return;
    }
    
    lastGeneratedView = 'star-map'; // Track this view
    console.log("âœ… Set lastGeneratedView to: star-map");
    
    const dimensions = resetCanvasToUserDimensions();
    alert("Computing star map. This may take a while depending on your internet connection.");
    
    window.currentViewType = 'star-map';
    
    const canvas = document.getElementById('star-map-canvas');
    const ctx = canvas.getContext('2d');
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const bgColor = document.getElementById('bg-color-canvas').value || '#F5F5DC';
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const radiusPercent = parseInt(document.getElementById('circle-radius-percent').value) || 60;
    
    // FIXED: Use single radius for perfect circle
    const minDim = Math.min(canvas.width, canvas.height);
    const radius = (minDim * radiusPercent) / 200;
    
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    console.log(`ğŸ”µ PERFECT CIRCLE: radius=${radius}, center=${centerX},${centerY}`);
    
    const borderWidth = parseInt(document.getElementById('border-width').value) || 1;
    const borderColor = document.getElementById('border-color').value || '#FFFFFF';
    
    // Draw border with arc (perfect circle)
    if (borderWidth > 0) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.lineWidth = borderWidth;
        ctx.strokeStyle = borderColor;
        ctx.stroke();
    }
    
    // Create circular clipping path with arc (perfect circle)
    ctx.save();
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.clip();
    
    // Get coordinates
    const latString = document.getElementById('latitude').value;
    const lngString = document.getElementById('longitude').value;
    
    let lat, lng;
    if (typeof parseFormattedCoordinate === 'function') {
        lat = parseFormattedCoordinate(latString, 'latitude');
        lng = parseFormattedCoordinate(lngString, 'longitude');
    } else {
        const parseCoord = (str) => {
            if (!str) return null;
            const match = str.match(/([NS])(\d+)Â°\s+(\d+\.\d+)â€²/i);
            if (match) {
                const direction = match[1].toUpperCase();
                const degrees = parseInt(match[2]);
                const minutes = parseFloat(match[3]);
                let decimal = degrees + (minutes / 60);
                if (direction === 'S') decimal = -decimal;
                return decimal;
            }
            return parseFloat(str);
        };
        lat = parseCoord(latString);
        lng = parseCoord(lngString);
    }
    
    if (isNaN(lat) || isNaN(lng)) {
        console.error("Failed to parse coordinates:", latString, lngString);
        alert("Invalid coordinates format. Please check your input.");
        ctx.restore();
        return;
    }
    
    // Fetch and render star map
    const date = document.getElementById('date').value || new Date().toISOString().split('T')[0];
    const starMapStyle = document.getElementById('star-map-style').value || 'default';
    
    let lstHours = 0;
    if (typeof calculateLST === 'function') {
        lstHours = calculateLST(date, lng);
        if (isNaN(lstHours)) lstHours = 0;
    }
    
    const requestBody = {
        style: starMapStyle,
        output: { width: 1000, height: 1000, format: "png" },
        observer: { latitude: lat, longitude: lng, date: date },
        view: {
            type: "area",
            parameters: {
                position: { equatorial: { rightAscension: lstHours, declination: lat } },
                backgroundColor: "#000033"
            }
        }
    };
    
    fetch('proxy/star_map_proxy.php', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Accept': 'image/png' },
        body: JSON.stringify(requestBody)
    })
    .then(response => {
        if (!response.ok) throw new Error(`Proxy error: ${response.status}`);
        return response.blob();
    })
    .then(blob => {
        const starMapUrl = URL.createObjectURL(blob);
        const img = new Image();
        img.crossOrigin = "Anonymous";
        
        img.onload = function() {
            // Scale to fill the circle
            const scale = Math.max(radius * 2 / img.width, radius * 2 / img.height);
            const drawWidth = img.width * scale;
            const drawHeight = img.height * scale;
            
            ctx.drawImage(img, centerX - drawWidth / 2, centerY - drawHeight / 2, drawWidth, drawHeight);
            ctx.restore();
            
            // NO TEXT LAYERS - Star Map is bare image for design use
            
            document.getElementById('download-star-map-btn').disabled = false;
            applyPreviewDisplayConstraints(document.getElementById('zoom-slider')?.value || 100);
            console.log("ğŸ”µ Star map rendered with PERFECT CIRCLE");
            URL.revokeObjectURL(starMapUrl);
        };
        
        img.onerror = function() {
            console.error("Failed to load star map image");
            ctx.restore();
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
            ctx.fillStyle = "#000033";
            ctx.fill();
            document.getElementById('download-star-map-btn').disabled = false;
            alert("Failed to load star map image. Check your internet connection.");
        };
        
        img.src = starMapUrl;
    })
    .catch(error => {
        console.warn("Proxy failed; drawing fallback:", error);
        try {
            const numStars = 1500;
            for (let i = 0; i < numStars; i++) {
                const a = Math.random() * Math.PI * 2;
                const d = Math.random() * (radius * 0.98);
                const x = centerX + Math.cos(a) * d;
                const y = centerY + Math.sin(a) * d;
                const r = Math.random() * 1.2 + 0.2;
                const o = 0.5 + Math.random() * 0.5;
                ctx.fillStyle = `rgba(255,255,255,${o.toFixed(2)})`;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            
            // NO TEXT LAYERS - Star Map is bare image for design use
            
            document.getElementById('download-star-map-btn').disabled = false;
        } catch (e) {
            console.error('Fallback failed:', e);
            ctx.restore();
        }
    });
}

/**
 * View the star map using the Canvas Layout option
 * This version INCLUDES text layers (unlike bare Star Map button)
 */
function viewStarMapOnCanvas() {
    console.log('ğŸ”µ View Star Map (Canvas Layout) clicked - WITH TEXT');
    
    if (!validateCoordinates()) {
        alert("Please enter valid coordinates or a location first.");
        return;
    }
    
    lastGeneratedView = 'star-map-canvas'; // Track this view
    console.log("âœ… Set lastGeneratedView to: star-map-canvas");
    
    const dimensions = resetCanvasToUserDimensions();
    alert("Computing star map. This may take a while depending on your internet connection.");
    
    window.currentViewType = 'star-map-canvas';
    
    const canvas = document.getElementById('star-map-canvas');
    const ctx = canvas.getContext('2d');
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const bgColor = document.getElementById('bg-color-canvas').value || '#F5F5DC';
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const radiusPercent = parseInt(document.getElementById('circle-radius-percent').value) || 60;
    const minDim = Math.min(canvas.width, canvas.height);
    const radius = (minDim * radiusPercent) / 200;
    
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    const borderWidth = parseInt(document.getElementById('border-width').value) || 1;
    const borderColor = document.getElementById('border-color').value || '#FFFFFF';
    
    if (borderWidth > 0) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.lineWidth = borderWidth;
        ctx.strokeStyle = borderColor;
        ctx.stroke();
    }
    
    ctx.save();
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.clip();
    
    const latString = document.getElementById('latitude').value;
    const lngString = document.getElementById('longitude').value;
    
    let lat, lng;
    if (typeof parseFormattedCoordinate === 'function') {
        lat = parseFormattedCoordinate(latString, 'latitude');
        lng = parseFormattedCoordinate(lngString, 'longitude');
    } else {
        const parseCoord = (str) => {
            if (!str) return null;
            const match = str.match(/([NS])(\d+)Â°\s+(\d+\.\d+)â€²/i);
            if (match) {
                const direction = match[1].toUpperCase();
                const degrees = parseInt(match[2]);
                const minutes = parseFloat(match[3]);
                let decimal = degrees + (minutes / 60);
                if (direction === 'S') decimal = -decimal;
                return decimal;
            }
            return parseFloat(str);
        };
        lat = parseCoord(latString);
        lng = parseCoord(lngString);
    }
    
    if (isNaN(lat) || isNaN(lng)) {
        console.error("Failed to parse coordinates:", latString, lngString);
        alert("Invalid coordinates format. Please check your input.");
        ctx.restore();
        return;
    }
    
    const date = document.getElementById('date').value || new Date().toISOString().split('T')[0];
    const starMapStyle = document.getElementById('star-map-style').value || 'default';
    
    let lstHours = 0;
    if (typeof calculateLST === 'function') {
        lstHours = calculateLST(date, lng);
        if (isNaN(lstHours)) lstHours = 0;
    }
    
    const requestBody = {
        style: starMapStyle,
        output: { width: 1000, height: 1000, format: "png" },
        observer: { latitude: lat, longitude: lng, date: date },
        view: {
            type: "area",
            parameters: {
                position: { equatorial: { rightAscension: lstHours, declination: lat } },
                backgroundColor: "#000033"
            }
        }
    };
    
    fetch('proxy/star_map_proxy.php', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Accept': 'image/png' },
        body: JSON.stringify(requestBody)
    })
    .then(response => {
        if (!response.ok) throw new Error(`Proxy error: ${response.status}`);
        return response.blob();
    })
    .then(blob => {
        const starMapUrl = URL.createObjectURL(blob);
        const img = new Image();
        img.crossOrigin = "Anonymous";
        
        img.onload = function() {
            const scale = Math.max(radius * 2 / img.width, radius * 2 / img.height);
            const drawWidth = img.width * scale;
            const drawHeight = img.height * scale;
            
            ctx.drawImage(img, centerX - drawWidth / 2, centerY - drawHeight / 2, drawWidth, drawHeight);
            ctx.restore();
            
            // CANVAS LAYOUT INCLUDES TEXT LAYERS
            renderTextLayers(ctx, centerX, centerY, radius, borderWidth);
            
            document.getElementById('download-star-map-canvas-btn').disabled = false;
            applyPreviewDisplayConstraints(document.getElementById('zoom-slider')?.value || 100);
            console.log("ğŸ”µ Canvas Layout rendered with text layers");
            URL.revokeObjectURL(starMapUrl);
        };
        
        img.onerror = function() {
            console.error("Failed to load star map image");
            ctx.restore();
            renderTextLayers(ctx, centerX, centerY, radius, borderWidth);
            document.getElementById('download-star-map-canvas-btn').disabled = false;
            alert("Failed to load star map image. Check your internet connection.");
        };
        
        img.src = starMapUrl;
    })
    .catch(error => {
        console.warn("Proxy failed; drawing fallback:", error);
        try {
            const numStars = 1500;
            for (let i = 0; i < numStars; i++) {
                const a = Math.random() * Math.PI * 2;
                const d = Math.random() * (radius * 0.98);
                const x = centerX + Math.cos(a) * d;
                const y = centerY + Math.sin(a) * d;
                const r = Math.random() * 1.2 + 0.2;
                const o = 0.5 + Math.random() * 0.5;
                ctx.fillStyle = `rgba(255,255,255,${o.toFixed(2)})`;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            renderTextLayers(ctx, centerX, centerY, radius, borderWidth);
            document.getElementById('download-star-map-canvas-btn').disabled = false;
        } catch (e) {
            console.error('Fallback failed:', e);
            ctx.restore();
        }
    });
}

// --- Shared helpers for combined views ---
function getParsedCoords() {
    const latStr = (document.getElementById('latitude') || {}).value || '';
    const lngStr = (document.getElementById('longitude') || {}).value || '';
    let lat, lng;
    if (typeof parseFormattedCoordinate === 'function') {
        lat = parseFormattedCoordinate(latStr, 'latitude');
        lng = parseFormattedCoordinate(lngStr, 'longitude');
    } else {
        lat = parseFloat(latStr);
        lng = parseFloat(lngStr);
    }
    return { lat, lng };
}

function fetchStarPng(lat, lng, dim) {
    const date = (document.getElementById('date') || {}).value || new Date().toISOString().split('T')[0];
    const style = (document.getElementById('star-map-style') || {}).value || 'default';
    let lstHours = 0;
    if (typeof calculateLST === 'function') {
        lstHours = calculateLST(date, lng);
        if (isNaN(lstHours)) lstHours = 0;
    }
    const body = {
        style,
        output: { width: dim, height: dim, format: 'png' },
        observer: { latitude: lat, longitude: lng, date },
        view: { type: 'area', parameters: { position: { equatorial: { rightAscension: lstHours, declination: lat } }, backgroundColor: '#000033' } }
    };
    return fetch('proxy/star_map_proxy.php', {
        method: 'POST', headers: { 'Content-Type': 'application/json', 'Accept': 'image/png' }, body: JSON.stringify(body)
    }).then(r => { if (!r.ok) throw new Error('star proxy ' + r.status); return r.blob(); })
      .then(blob => new Promise((res, rej) => { const img = new Image(); img.onload = () => res(img); img.onerror = rej; img.src = URL.createObjectURL(blob); }));
}

function fetchStreetPng(lat, lng, dim) {
    // Use direct Google Maps API
    const apiKey = 'AIzaSyCpvv1IJYxwGVMh24MLFDH6LmupseApSZU';
    const markers = `color:red|${lat},${lng}`;
    const url = `https://maps.googleapis.com/maps/api/staticmap?center=${lat},${lng}&zoom=12&size=${dim}x${dim}&maptype=roadmap&markers=${encodeURIComponent(markers)}&key=${apiKey}`;
    
    console.log('ğŸ”µ Fetching street map via direct API:', url);
    
    return new Promise((res, rej) => { 
        const img = new Image(); 
        img.crossOrigin = "anonymous";
        img.onload = () => {
            console.log('âœ… Street map loaded via direct API');
            res(img);
        }; 
        img.onerror = (e) => {
            console.error('âŒ Street map load failed:', e);
            rej(e);
        }; 
        img.src = url; 
    });
}

// FIXED: drawImageInCircle uses arc() for perfect circles
function drawImageInCircle(ctx, img, cx, cy, r) {
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2, true);  // Perfect circle
    ctx.closePath();
    ctx.clip();
    
    // Scale to fill circle
    const scale = Math.max(r * 2 / img.width, r * 2 / img.height);
    const drawW = img.width * scale;
    const drawH = img.height * scale;
    
    ctx.drawImage(img, cx - drawW / 2, cy - drawH / 2, drawW, drawH);
    ctx.restore();
    
    console.log(`ğŸ”µ Drew image in PERFECT CIRCLE at (${cx}, ${cy}) radius=${r}`);
}

function viewCombined(isLandscape) {
    console.log('ğŸ”µ View Combined clicked, landscape=', isLandscape);
    if (!validateCoordinates()) { alert('Please enter valid coordinates first.'); return; }
    
    const { width, height } = resetCanvasToUserDimensions();
    const canvas = document.getElementById('star-map-canvas');
    const ctx = canvas.getContext('2d');
    
    const bgColor = (document.getElementById('bg-color-canvas') || {}).value || '#F5F5DC';
    console.log(`ğŸ”µ Retrieved bgColor: ${bgColor} for ${isLandscape ? 'LANDSCAPE' : 'PORTRAIT'}`);

    // Set canvas dimensions based on button clicked
    // Setting dimensions automatically clears the canvas
    if (isLandscape) {
        canvas.width = Math.max(width, height);
        canvas.height = Math.min(width, height);
    } else {
        canvas.width = Math.min(width, height);
        canvas.height = Math.max(width, height);
    }
    
    console.log(`ğŸ”µ Canvas dimensions set to: ${canvas.width} x ${canvas.height}`);
    
    // Fill with background color immediately after setting dimensions
    ctx.fillStyle = bgColor; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    console.log(`ğŸ”µ Background filled with color: ${bgColor}`);

    // FIXED: Use smaller radius for portrait to leave text space
    const radiusPercent = isLandscape ? 
        parseInt((document.getElementById('circle-radius-percent') || {}).value) || 60 : 
        50; // Force 50% for portrait mode to ensure text space
    
    console.log(`ğŸ”µ Radius: ${radiusPercent}% for ${isLandscape ? 'LANDSCAPE' : 'PORTRAIT'}`);
    
    const minDim = Math.min(canvas.width, canvas.height);
    const r = (minDim * radiusPercent) / 200;
    
    const overlap = parseInt((document.getElementById('circle-overlap-percent') || {}).value) || 10;
    const sep = (2 * r) * (1 - (Math.max(0, Math.min(100, overlap)) / 100));
    const streetFirst = (function(){ const radio = document.querySelector('input[name="map-order"]:checked'); return radio ? (radio.value === 'street-first') : true; })();
    const center = { x: canvas.width / 2, y: canvas.height / 2 };
    const c1 = isLandscape ? { x: center.x - sep / 2, y: center.y } : { x: center.x, y: center.y - sep / 2 };
    const c2 = isLandscape ? { x: center.x + sep / 2, y: center.y } : { x: center.x, y: center.y + sep / 2 };
    
    console.log(`ğŸ”µ Combined view: ${isLandscape ? 'LANDSCAPE' : 'PORTRAIT'}, radius=${r}`);
    
    const { lat, lng } = getParsedCoords();
    const dim = Math.min(640, Math.round(r * 2));
    
    const borderWidth = parseInt((document.getElementById('border-width') || {}).value) || 2;
    const borderColor = (document.getElementById('border-color') || {}).value || '#FDCA0D';

    // Fetch both images
    Promise.all([fetchStreetPng(lat, lng, dim), fetchStarPng(lat, lng, dim)])
        .then(([streetImg, starImg]) => {
            // Draw Street Map at c1
            drawImageInCircle(ctx, streetImg, c1.x, c1.y, r);
            
            // Draw Star Map at c2 (on top)
            drawImageInCircle(ctx, starImg, c2.x, c2.y, r);
            
            // Draw borders with masking using composite operation
            if (borderWidth > 0) {
                // Create temporary canvas
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Draw both borders on temp canvas
                tempCtx.strokeStyle = borderColor;
                tempCtx.lineWidth = borderWidth;
                tempCtx.beginPath();
                tempCtx.arc(c1.x, c1.y, r, 0, Math.PI * 2);
                tempCtx.stroke();
                tempCtx.beginPath();
                tempCtx.arc(c2.x, c2.y, r, 0, Math.PI * 2);
                tempCtx.stroke();
                
                // Erase the overlap area from BOTH borders
                tempCtx.globalCompositeOperation = 'destination-out';
                tempCtx.fillStyle = 'black';
                
                // Calculate intersection and erase it
                // Erase a region that covers where both circles overlap
                const distance = Math.sqrt(Math.pow(c2.x - c1.x, 2) + Math.pow(c2.y - c1.y, 2));
                if (distance < 2 * r) {
                    // Circles overlap - erase almost to outer edge to remove all border slivers
                    // Erase to outer edge minus 1 pixel
                    tempCtx.beginPath();
                    tempCtx.arc(c1.x, c1.y, r - 1, 0, Math.PI * 2);
                    tempCtx.fill();
                    // Erase circle 2 to outer edge minus 1 pixel
                    tempCtx.beginPath();
                    tempCtx.arc(c2.x, c2.y, r - 1, 0, Math.PI * 2);
                    tempCtx.fill();
                }
                
                // Copy the result to main canvas
                ctx.drawImage(tempCanvas, 0, 0);
            }
            
            // Text rendering - use actual circle radius for consistent positioning
            const canvasCenterX = canvas.width / 2;
            const canvasCenterY = canvas.height / 2;
            
            // For PORTRAIT: Push text further from circles (higher above, lower below)
            let textRadius = r;
            if (!isLandscape) {
                // Portrait: INCREASE radius by 80% to push text further out
                textRadius = r * 1.80;
                console.log(`ğŸ”µ Portrait mode: Increased text radius to ${textRadius.toFixed(0)}px (from ${r.toFixed(0)}px)`);
            }
            
            renderTextLayers(ctx, canvasCenterX, canvasCenterY, textRadius, borderWidth);
            
            applyPreviewDisplayConstraints(document.getElementById('zoom-slider')?.value || 100);
            console.log('ğŸ”µ Combined view complete');
        })
        .catch(e => { 
            console.error('Combined view error:', e); 
            alert('Failed to render combined view. Error: ' + e.message); 
        });
}

function viewStarStreetLandscape(){ 
    lastGeneratedView = 'star-street-landscape'; // Track this view
    console.log("âœ… Set lastGeneratedView to: star-street-landscape");
    viewCombined(true); 
}
function viewStarStreetPortrait(){ 
    lastGeneratedView = 'star-street-portrait'; // Track this view
    console.log("âœ… Set lastGeneratedView to: star-street-portrait");
    viewCombined(false); 
}

/**
 * View the street map (Google Map) in a circle
 * FIXED VERSION - Uses arc() for perfect circles
 */
function viewStreetMap() {
    console.log("ğŸ”µ View Street Map button clicked - FIXED VERSION");
    
    if (!validateCoordinates()) {
        alert("Please enter valid coordinates or a location first.");
        return;
    }
    
    lastGeneratedView = 'street-map'; // Track this view
    console.log("âœ… Set lastGeneratedView to: street-map");
    
    const dimensions = resetCanvasToUserDimensions();
    window.currentViewType = 'street-map';
    
    const canvas = document.getElementById('star-map-canvas');
    const ctx = canvas.getContext('2d');
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const bgColor = document.getElementById('bg-color-canvas').value || '#F5F5DC';
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const radiusPercent = parseInt(document.getElementById('circle-radius-percent').value) || 60;
    
    // FIXED: Use single radius for perfect circle
    const minDim = Math.min(canvas.width, canvas.height);
    const radius = (minDim * radiusPercent) / 200;
    
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    console.log(`ğŸ”µ PERFECT CIRCLE: radius=${radius}, center=${centerX},${centerY}`);
    
    const borderWidth = parseInt(document.getElementById('border-width').value) || 1;
    const borderColor = document.getElementById('border-color').value || '#FDCA0D';
    
    // Draw border with arc (perfect circle)
    if (borderWidth > 0) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.lineWidth = borderWidth;
        ctx.strokeStyle = borderColor;
        ctx.stroke();
    }
    
    // Create circular clipping with arc (perfect circle)
    ctx.save();
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.clip();
    
    // Get coordinates
    const latString = document.getElementById('latitude').value;
    const lngString = document.getElementById('longitude').value;
    
    let lat, lng;
    if (typeof parseFormattedCoordinate === 'function') {
        lat = parseFormattedCoordinate(latString, 'latitude');
        lng = parseFormattedCoordinate(lngString, 'longitude');
    } else {
        const parseCoord = (str) => {
            if (!str) return null;
            const match = str.match(/([NS])(\d+)Â°\s+(\d+\.\d+)â€²/i);
            if (match) {
                const direction = match[1].toUpperCase();
                const degrees = parseInt(match[2]);
                const minutes = parseFloat(match[3]);
                let decimal = degrees + (minutes / 60);
                if (direction === 'S') decimal = -decimal;
                return decimal;
            }
            return parseFloat(str);
        };
        lat = parseCoord(latString);
        lng = parseCoord(lngString);
    }
    
    if (isNaN(lat) || isNaN(lng)) {
        console.error("Failed to parse coordinates:", latString, lngString);
        alert("Invalid coordinates format. Please check your input.");
        ctx.restore();
        return;
    }
    
    const mapSize = Math.min(radius * 2, 640);
    // Use direct Google Maps API
    const apiKey = 'AIzaSyCpvv1IJYxwGVMh24MLFDH6LmupseApSZU';
    const markers = `color:red|${lat},${lng}`;
    const mapUrl = `https://maps.googleapis.com/maps/api/staticmap?center=${lat},${lng}&zoom=12&size=${mapSize}x${mapSize}&maptype=roadmap&markers=${encodeURIComponent(markers)}&key=${apiKey}`;
    
    console.log('ğŸ”µ Loading street map via direct API:', mapUrl);
    
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = function() {
        console.log('âœ… Street map loaded successfully');
        // Scale to fill the circle
        const scale = Math.max(radius * 2 / img.width, radius * 2 / img.height);
        const drawWidth = img.width * scale;
        const drawHeight = img.height * scale;
        
        ctx.drawImage(img, centerX - drawWidth / 2, centerY - drawHeight / 2, drawWidth, drawHeight);
        ctx.restore();
        
        // Add center marker
        ctx.beginPath();
        ctx.arc(centerX, centerY, 5, 0, Math.PI * 2, true);
        ctx.fillStyle = "#FF0000";
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#000000";
        ctx.stroke();
        
        // NO TEXT LAYERS - Street Map is bare image for design use
        
        document.getElementById('download-street-map-btn').disabled = false;
        applyPreviewDisplayConstraints(document.getElementById('zoom-slider')?.value || 100);
        console.log("ğŸ”µ Street map rendered with PERFECT CIRCLE");
    };
    
    img.onerror = function() {
        console.error("Failed to load street map");
        ctx.restore();
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
        ctx.fillStyle = "#FFFFFF";
        ctx.fill();
        document.getElementById('download-street-map-btn').disabled = false;
        alert("Failed to load Google Maps image. Check your internet connection or backend proxy.");
    };
    
    img.src = mapUrl;
}

/**
 * Download functions with proper validation and alerts
 */
function downloadStarMap() {
    console.log("ğŸ”µ Download Star Map button clicked");
    simpleDownload('star-map');
}

function downloadStreetMap() {
    console.log("ğŸ”µ Download Street Map button clicked");
    simpleDownload('street-map');
}

function downloadStarMapWithCanvas() {
    console.log("ğŸ”µ Download Canvas Layout button clicked");
    simpleDownload('star-map-canvas');
}

function downloadStarStreetLandscape() {
    console.log("ğŸ”µ Download Combined Landscape button clicked");
    simpleDownload('star-street-landscape');
}

function downloadStarStreetPortrait() {
    console.log("ğŸ”µ Download Combined Portrait button clicked");
    simpleDownload('star-street-portrait');
}

// ENHANCED download function with comprehensive validation and alerts
function simpleDownload(viewType) {
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log('ğŸ”µ DOWNLOAD INITIATED');
    console.log('   Requested view type:', viewType);
    console.log('   Last generated view:', lastGeneratedView);
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    
    // Step 1: Check if canvas exists
    const canvas = document.getElementById('star-map-canvas');
    if (!canvas) {
        const msg = 'âŒ ERROR: Canvas element not found. Please reload the page.';
        console.error(msg);
        alert('Canvas not found. Please reload the page and try again.');
        return;
    }
    
    console.log('âœ… Canvas found');
    console.log('   Canvas dimensions:', canvas.width, 'x', canvas.height);
    
    // Step 2: Check if canvas has content (reasonable dimensions)
    if (canvas.width < 100 || canvas.height < 100) {
        const msg = 'âš ï¸ Canvas is empty or too small';
        console.warn(msg);
        alert('Please click one of the YELLOW "View Options" buttons above to generate your desired image first.\n\nThen use the corresponding GREEN download button.');
        return;
    }
    
    console.log('âœ… Canvas has content');
    
    // Step 3: Check if the correct view was generated
    if (lastGeneratedView !== viewType) {
        const viewNames = {
            'star-map': 'Star Map',
            'street-map': 'Street Map',
            'star-map-canvas': 'Canvas Layout',
            'star-street-landscape': 'Combined Landscape',
            'star-street-portrait': 'Combined Portrait'
        };
        
        const requestedName = viewNames[viewType] || viewType;
        const generatedName = viewNames[lastGeneratedView] || (lastGeneratedView || 'None');
        
        const msg = `âš ï¸ VIEW MISMATCH!\n\nYou clicked download for: ${requestedName}\nBut the canvas shows: ${generatedName}\n\nPlease click the YELLOW "View ${requestedName}" button first, then download.`;
        console.warn('âŒ VIEW MISMATCH');
        console.warn('   Requested:', viewType);
        console.warn('   Generated:', lastGeneratedView);
        alert(msg);
        return;
    }
    
    console.log('âœ… View type matches');
    
    // Step 4: Get download format
    const formatRadios = document.getElementsByName('image-format');
    let format = 'png';
    for (const radio of formatRadios) {
        if (radio.checked) {
            format = radio.value.toLowerCase();
            break;
        }
    }
    
    console.log('   Format:', format);
    
    // Step 5: Check format support (PNG/JPG only for now)
    if (format !== 'png' && format !== 'jpg' && format !== 'jpeg') {
        console.warn('âš ï¸ Unsupported format:', format);
        alert(`${format.toUpperCase()} download is not yet implemented.\n\nPlease select PNG or JPG format.`);
        return;
    }
    
    console.log('âœ… Format supported');
    
    // Step 6: Get event name and date for filename
    const occasionEl = document.getElementById('occasion');
    const customOccasionEl = document.getElementById('custom-occasion');
    const dateEl = document.getElementById('date');
    
    let eventName = 'Star-Map';
    if (occasionEl) {
        if (occasionEl.value === 'custom' && customOccasionEl && customOccasionEl.value) {
            eventName = customOccasionEl.value.replace(/\s+/g, '-');
        } else if (occasionEl.value) {
            eventName = occasionEl.options[occasionEl.selectedIndex].text.replace(/\s+/g, '-');
        }
    }
    
    const date = dateEl ? dateEl.value : '2024-01-01';
    
    // Map type names for filename
    const mapTypeNames = {
        'star-map': 'Star-Map',
        'street-map': 'Street-Map',
        'star-map-canvas': 'Canvas-Layout',
        'star-street-landscape': 'Combined-Landscape',
        'star-street-portrait': 'Combined-Portrait'
    };
    
    const mapType = mapTypeNames[viewType] || viewType;
    const extension = (format === 'jpg' || format === 'jpeg') ? 'jpg' : 'png';
    const filename = `${eventName}-${mapType}-${date}.${extension}`;
    
    console.log('   Filename:', filename);
    console.log('   Event:', eventName);
    console.log('   Date:', date);
    
    // Step 7: Attempt download
    console.log('ğŸ”„ Attempting to generate download...');
    
    try {
        const link = document.createElement('a');
        
        if (format === 'png') {
            link.href = canvas.toDataURL('image/png');
        } else {
            link.href = canvas.toDataURL('image/jpeg', 0.95);
        }
        
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        console.log('âœ… DOWNLOAD SUCCESSFUL');
        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        
        alert(`âœ… Download successful!\n\nFile: ${filename}`);
        
    } catch (error) {
        console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        console.error('âŒ DOWNLOAD FAILED');
        console.error('   Error:', error.name);
        console.error('   Message:', error.message);
        console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        
        // Specific error handling for cross-origin issues
        if (error.name === 'SecurityError' || error.message.includes('tainted') || error.message.includes('cross-origin')) {
            alert('âŒ Download failed due to browser security restrictions.\n\n' +
                  'The canvas contains cross-origin images that cannot be downloaded.\n\n' +
                  'WORKAROUND: Use your browser\'s screenshot tool or the Print Screen key to capture the image.');
        } else {
            alert(`âŒ Download failed\n\nError: ${error.message}\n\nPlease try again or use a screenshot tool.`);
        }
    }
}


/* END OF CODE - Emergent - 2025-10-21 [18:06:30-EST] */
